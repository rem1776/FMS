<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FMS: mpp_mod</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FMS
   &#160;<span id="projectnumber">2021.02.0</span>
   </div>
   <div id="projectbrief">Flexible Modeling System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__mpp__mod.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mpp_mod<div class="ingroups"><a class="el" href="group__mpp.html">MPP</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A set of simple calls to provide a uniform interface to different message-passing libraries. It currently can be implemented either in the SGI/Cray native SHMEM library or in the MPI standard. Other libraries (e.g MPI-2, Co-Array Fortran) can be incorporated as the need arises.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1event.html">event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1clock.html">clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a clock contains an array of event profiles for a region  <a href="structmpp__mod_1_1clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1clock__data__summary.html">clock_data_summary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summary of information from a clock run.  <a href="structmpp__mod_1_1clock__data__summary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1summary__struct.html">summary_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds name and clock data for use in mpp_util.h  <a href="structmpp__mod_1_1summary__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data types for generalized data transfer (e.g. MPI_Type)  <a href="structmpp__mod_1_1mpp__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpp__mod_1_1mpp__type__list.html">mpp_type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persisent elements for linked list interaction.  <a href="structmpp__mod_1_1mpp__type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga35e2b28da23dc25b1ad90bff6cc7e390"><td class="memItemLeft" align="right" valign="top"><a id="ga35e2b28da23dc25b1ad90bff6cc7e390"></a>
character(len=32)&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:ga35e2b28da23dc25b1ad90bff6cc7e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a1c9998bceda90023a214be60c5d03"><td class="memItemLeft" align="right" valign="top"><a id="gaa0a1c9998bceda90023a214be60c5d03"></a>
integer, dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>list</b> =&gt;NULL()</td></tr>
<tr class="separator:gaa0a1c9998bceda90023a214be60c5d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a5f046f5e5f16ffa119020e5c5aec5"><td class="memItemLeft" align="right" valign="top"><a id="ga04a5f046f5e5f16ffa119020e5c5aec5"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>count</b></td></tr>
<tr class="separator:ga04a5f046f5e5f16ffa119020e5c5aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e5e5f9e856a54e632d09f5b0f858a3"><td class="memItemLeft" align="right" valign="top"><a id="ga66e5e5f9e856a54e632d09f5b0f858a3"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>start</b></td></tr>
<tr class="separator:ga66e5e5f9e856a54e632d09f5b0f858a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899a46fa3b4c7273be1f6d1f3254c4a4"><td class="memItemLeft" align="right" valign="top"><a id="ga899a46fa3b4c7273be1f6d1f3254c4a4"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpp__mod.html#ga899a46fa3b4c7273be1f6d1f3254c4a4">log2stride</a></td></tr>
<tr class="memdesc:ga899a46fa3b4c7273be1f6d1f3254c4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy variables when libMPI is defined. <br /></td></tr>
<tr class="separator:ga899a46fa3b4c7273be1f6d1f3254c4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01795d202d42911850a69913f8a8f0e8"><td class="memItemLeft" align="right" valign="top"><a id="ga01795d202d42911850a69913f8a8f0e8"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="separator:ga01795d202d42911850a69913f8a8f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba76bb9f9a94df8fe61cb4f48d04fe4"><td class="memItemLeft" align="right" valign="top"><a id="ga5ba76bb9f9a94df8fe61cb4f48d04fe4"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpp__mod.html#ga5ba76bb9f9a94df8fe61cb4f48d04fe4">group</a></td></tr>
<tr class="memdesc:ga5ba76bb9f9a94df8fe61cb4f48d04fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI communicator and group id for this PE set. <br /></td></tr>
<tr class="separator:ga5ba76bb9f9a94df8fe61cb4f48d04fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6faa9a85c83966eb1298921b496da89"><td class="memItemLeft" align="right" valign="top"><a id="gab6faa9a85c83966eb1298921b496da89"></a>
character(len=16)&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:gab6faa9a85c83966eb1298921b496da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c0c2c98928faae2a00ed39d484b6fe"><td class="memItemLeft" align="right" valign="top"><a id="ga33c0c2c98928faae2a00ed39d484b6fe"></a>
integer(i8_kind), dimension(max_events)&#160;</td><td class="memItemRight" valign="bottom"><b>ticks</b></td></tr>
<tr class="separator:ga33c0c2c98928faae2a00ed39d484b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f01b282fd9d0617939b6d6f0f03ad0a"><td class="memItemLeft" align="right" valign="top"><a id="ga8f01b282fd9d0617939b6d6f0f03ad0a"></a>
integer(i8_kind), dimension(max_events)&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b></td></tr>
<tr class="separator:ga8f01b282fd9d0617939b6d6f0f03ad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41f41bedc8550ea96328c58fb502802"><td class="memItemLeft" align="right" valign="top"><a id="gad41f41bedc8550ea96328c58fb502802"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>calls</b></td></tr>
<tr class="separator:gad41f41bedc8550ea96328c58fb502802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e2b28da23dc25b1ad90bff6cc7e390"><td class="memItemLeft" align="right" valign="top"><a id="ga35e2b28da23dc25b1ad90bff6cc7e390"></a>
character(len=32)&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:ga35e2b28da23dc25b1ad90bff6cc7e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37af47cb745e96a3ba2cb293e1338a87"><td class="memItemLeft" align="right" valign="top"><a id="ga37af47cb745e96a3ba2cb293e1338a87"></a>
integer(i8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>hits</b></td></tr>
<tr class="separator:ga37af47cb745e96a3ba2cb293e1338a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413de4584e7a91a7ed827a2c9c80b806"><td class="memItemLeft" align="right" valign="top"><a id="ga413de4584e7a91a7ed827a2c9c80b806"></a>
integer(i8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>tick</b></td></tr>
<tr class="separator:ga413de4584e7a91a7ed827a2c9c80b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdb1919e3100ca9d062600972e9e3d5"><td class="memItemLeft" align="right" valign="top"><a id="gaafdb1919e3100ca9d062600972e9e3d5"></a>
integer(i8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>total_ticks</b></td></tr>
<tr class="separator:gaafdb1919e3100ca9d062600972e9e3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d722a34d2e4200769ee9f0ad6296355"><td class="memItemLeft" align="right" valign="top"><a id="ga9d722a34d2e4200769ee9f0ad6296355"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>peset_num</b></td></tr>
<tr class="separator:ga9d722a34d2e4200769ee9f0ad6296355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e971e934253ae38bfd1d3e17065f088"><td class="memItemLeft" align="right" valign="top"><a id="ga0e971e934253ae38bfd1d3e17065f088"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>sync_on_begin</b></td></tr>
<tr class="separator:ga0e971e934253ae38bfd1d3e17065f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd54335ebddef116a874c27bf0bcc131"><td class="memItemLeft" align="right" valign="top"><a id="gacd54335ebddef116a874c27bf0bcc131"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>detailed</b></td></tr>
<tr class="separator:gacd54335ebddef116a874c27bf0bcc131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ea0bd55476160a2cd8239909873010"><td class="memItemLeft" align="right" valign="top"><a id="ga17ea0bd55476160a2cd8239909873010"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>grain</b></td></tr>
<tr class="separator:ga17ea0bd55476160a2cd8239909873010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8e3a26caaf27530a511be9aff7e815"><td class="memItemLeft" align="right" valign="top"><a id="ga8d8e3a26caaf27530a511be9aff7e815"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>events</b> =&gt;NULL()</td></tr>
<tr class="separator:ga8d8e3a26caaf27530a511be9aff7e815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd3880496ab226169e5485dec9236288"><td class="memItemLeft" align="right" valign="top"><a id="gadd3880496ab226169e5485dec9236288"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>if</b></td></tr>
<tr class="separator:gadd3880496ab226169e5485dec9236288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c34a28ebe273a969f087bb9ef6fd078"><td class="memItemLeft" align="right" valign="top"><a id="ga8c34a28ebe273a969f087bb9ef6fd078"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>needed</b></td></tr>
<tr class="separator:ga8c34a28ebe273a969f087bb9ef6fd078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052dbf1f3265378ba60339f851467031"><td class="memItemLeft" align="right" valign="top"><a id="ga052dbf1f3265378ba60339f851467031"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b></td></tr>
<tr class="separator:ga052dbf1f3265378ba60339f851467031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708e2636c818cbed21de03cede460bb3"><td class="memItemLeft" align="right" valign="top"><a id="ga708e2636c818cbed21de03cede460bb3"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>to</b></td></tr>
<tr class="separator:ga708e2636c818cbed21de03cede460bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6baba5612f64182a23aac04a68a02560"><td class="memItemLeft" align="right" valign="top"><a id="ga6baba5612f64182a23aac04a68a02560"></a>
type(<a class="el" href="structmpp__mod_1_1event.html">event</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>max_event_types</b></td></tr>
<tr class="separator:ga6baba5612f64182a23aac04a68a02560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373b51219413ac949498473e81f0328b"><td class="memItemLeft" align="right" valign="top"><a id="ga373b51219413ac949498473e81f0328b"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>is_on</b></td></tr>
<tr class="separator:ga373b51219413ac949498473e81f0328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0682427ac2768082b53f1a45d5c10b3"><td class="memItemLeft" align="right" valign="top"><a id="gab0682427ac2768082b53f1a45d5c10b3"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b></td></tr>
<tr class="separator:gab0682427ac2768082b53f1a45d5c10b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d9aefc9c74fb6a677c72acbe5364c18"><td class="memItemLeft" align="right" valign="top"><a id="ga5d9aefc9c74fb6a677c72acbe5364c18"></a>
logical, pointer&#160;</td><td class="memItemRight" valign="bottom"><b>to</b></td></tr>
<tr class="separator:ga5d9aefc9c74fb6a677c72acbe5364c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696249f7e1ec8e9b4c2d9df08d13e3e3"><td class="memItemLeft" align="right" valign="top"><a id="ga696249f7e1ec8e9b4c2d9df08d13e3e3"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>false</b></td></tr>
<tr class="separator:ga696249f7e1ec8e9b4c2d9df08d13e3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a73407cc4e29d4f65cb3700758fec0"><td class="memItemLeft" align="right" valign="top"><a id="ga68a73407cc4e29d4f65cb3700758fec0"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>set</b></td></tr>
<tr class="separator:ga68a73407cc4e29d4f65cb3700758fec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9196011c74e8670b9468c05e002f97c3"><td class="memItemLeft" align="right" valign="top"><a id="ga9196011c74e8670b9468c05e002f97c3"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>true</b></td></tr>
<tr class="separator:ga9196011c74e8670b9468c05e002f97c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7167ed3f1221613ad1bd2ad6c38c25b4"><td class="memItemLeft" align="right" valign="top"><a id="ga7167ed3f1221613ad1bd2ad6c38c25b4"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>when</b></td></tr>
<tr class="separator:ga7167ed3f1221613ad1bd2ad6c38c25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e1781993f06bec146aeb7086581f74"><td class="memItemLeft" align="right" valign="top"><a id="ga19e1781993f06bec146aeb7086581f74"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>calling</b></td></tr>
<tr class="separator:ga19e1781993f06bec146aeb7086581f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c46ba17d0336c53f4c631d22a476ee3"><td class="memItemLeft" align="right" valign="top"><a id="ga6c46ba17d0336c53f4c631d22a476ee3"></a>
logical&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_clock_begin</b></td></tr>
<tr class="separator:ga6c46ba17d0336c53f4c631d22a476ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6faa9a85c83966eb1298921b496da89"><td class="memItemLeft" align="right" valign="top"><a id="gab6faa9a85c83966eb1298921b496da89"></a>
character(len=16)&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:gab6faa9a85c83966eb1298921b496da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7b29f33ca350285165a55bd0d42970"><td class="memItemLeft" align="right" valign="top"><a id="gaea7b29f33ca350285165a55bd0d42970"></a>
real(r8_kind), dimension(max_bins)&#160;</td><td class="memItemRight" valign="bottom"><b>msg_size_sums</b></td></tr>
<tr class="separator:gaea7b29f33ca350285165a55bd0d42970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16613ee70b56ec2e78dfdf8565089b46"><td class="memItemLeft" align="right" valign="top"><a id="ga16613ee70b56ec2e78dfdf8565089b46"></a>
real(r8_kind), dimension(max_bins)&#160;</td><td class="memItemRight" valign="bottom"><b>msg_time_sums</b></td></tr>
<tr class="separator:ga16613ee70b56ec2e78dfdf8565089b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa011010c64f8d7bf280e832cbacd489e"><td class="memItemLeft" align="right" valign="top"><a id="gaa011010c64f8d7bf280e832cbacd489e"></a>
real(r8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>total_data</b></td></tr>
<tr class="separator:gaa011010c64f8d7bf280e832cbacd489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c8fffbfefd1c9a9c94283d1d5e8bcc7"><td class="memItemLeft" align="right" valign="top"><a id="ga4c8fffbfefd1c9a9c94283d1d5e8bcc7"></a>
real(r8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>total_time</b></td></tr>
<tr class="separator:ga4c8fffbfefd1c9a9c94283d1d5e8bcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e464ff8da790530d88429dfdd0b556"><td class="memItemLeft" align="right" valign="top"><a id="gaa9e464ff8da790530d88429dfdd0b556"></a>
integer(i8_kind), dimension(max_bins)&#160;</td><td class="memItemRight" valign="bottom"><b>msg_size_cnts</b></td></tr>
<tr class="separator:gaa9e464ff8da790530d88429dfdd0b556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60aa19c0416e441cae40406a2646f497"><td class="memItemLeft" align="right" valign="top"><a id="ga60aa19c0416e441cae40406a2646f497"></a>
integer(i8_kind)&#160;</td><td class="memItemRight" valign="bottom"><b>total_cnts</b></td></tr>
<tr class="separator:ga60aa19c0416e441cae40406a2646f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6faa9a85c83966eb1298921b496da89"><td class="memItemLeft" align="right" valign="top"><a id="gab6faa9a85c83966eb1298921b496da89"></a>
character(len=16)&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:gab6faa9a85c83966eb1298921b496da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca1fe58bbbabb0714408286c54b7bfc"><td class="memItemLeft" align="right" valign="top"><a id="ga4ca1fe58bbbabb0714408286c54b7bfc"></a>
type(<a class="el" href="structmpp__mod_1_1clock__data__summary.html">clock_data_summary</a>), dimension(max_event_types)&#160;</td><td class="memItemRight" valign="bottom"><b>event</b></td></tr>
<tr class="separator:ga4ca1fe58bbbabb0714408286c54b7bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc275b22749dc80269b8b4e3df9c90e"><td class="memItemLeft" align="right" valign="top"><a id="gabfc275b22749dc80269b8b4e3df9c90e"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>counter</b></td></tr>
<tr class="separator:gabfc275b22749dc80269b8b4e3df9c90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c38185f13106c3fd4496987503287f"><td class="memItemLeft" align="right" valign="top"><a id="gac1c38185f13106c3fd4496987503287f"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>number</b></td></tr>
<tr class="separator:gac1c38185f13106c3fd4496987503287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d903a41dab00e46cc54c881d9538f86"><td class="memItemLeft" align="right" valign="top"><a id="ga5d903a41dab00e46cc54c881d9538f86"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>of</b></td></tr>
<tr class="separator:ga5d903a41dab00e46cc54c881d9538f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f960ce5b1ab73a34897f3574171cfb"><td class="memItemLeft" align="right" valign="top"><a id="ga55f960ce5b1ab73a34897f3574171cfb"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>instances</b></td></tr>
<tr class="separator:ga55f960ce5b1ab73a34897f3574171cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3beefb3c8d792775f8f60d59fd2a5096"><td class="memItemLeft" align="right" valign="top"><a id="ga3beefb3c8d792775f8f60d59fd2a5096"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>this</b></td></tr>
<tr class="separator:ga3beefb3c8d792775f8f60d59fd2a5096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050ea25ea66f55517d85273e8d77c20a"><td class="memItemLeft" align="right" valign="top"><a id="ga050ea25ea66f55517d85273e8d77c20a"></a>
integer, dimension(e.g. mpi_byte)&#160;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr class="separator:ga050ea25ea66f55517d85273e8d77c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0ace96bdf67f71db5887ab1492ba95"><td class="memItemLeft" align="right" valign="top"><a id="ga8a0ace96bdf67f71db5887ab1492ba95"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>ndims</b></td></tr>
<tr class="separator:ga8a0ace96bdf67f71db5887ab1492ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3abb587651ee6d8f796e6049cce2ace4"><td class="memItemLeft" align="right" valign="top"><a id="ga3abb587651ee6d8f796e6049cce2ace4"></a>
integer, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><b>sizes</b></td></tr>
<tr class="separator:ga3abb587651ee6d8f796e6049cce2ace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f14f6b36b314d9ace86e9fd04ee54c"><td class="memItemLeft" align="right" valign="top"><a id="ga34f14f6b36b314d9ace86e9fd04ee54c"></a>
integer, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><b>subsizes</b></td></tr>
<tr class="separator:ga34f14f6b36b314d9ace86e9fd04ee54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6367378a55d3dc777cd499d182e34019"><td class="memItemLeft" align="right" valign="top"><a id="ga6367378a55d3dc777cd499d182e34019"></a>
integer, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><b>starts</b></td></tr>
<tr class="separator:ga6367378a55d3dc777cd499d182e34019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daabb7f747ff14c33c5050cee77d9da"><td class="memItemLeft" align="right" valign="top"><a id="ga3daabb7f747ff14c33c5050cee77d9da"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>etype</b></td></tr>
<tr class="separator:ga3daabb7f747ff14c33c5050cee77d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d24d5875ce9d57b026083f948660c8"><td class="memItemLeft" align="right" valign="top"><a id="ga60d24d5875ce9d57b026083f948660c8"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>elementary</b></td></tr>
<tr class="separator:ga60d24d5875ce9d57b026083f948660c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0cb30099ea483b6f621457dacae3e8"><td class="memItemLeft" align="right" valign="top"><a id="ga4f0cb30099ea483b6f621457dacae3e8"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:ga4f0cb30099ea483b6f621457dacae3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01795d202d42911850a69913f8a8f0e8"><td class="memItemLeft" align="right" valign="top"><a id="ga01795d202d42911850a69913f8a8f0e8"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="separator:ga01795d202d42911850a69913f8a8f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7739381485c7ccd8ae25d23b7e8903b6"><td class="memItemLeft" align="right" valign="top"><a id="ga7739381485c7ccd8ae25d23b7e8903b6"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>identifier</b></td></tr>
<tr class="separator:ga7739381485c7ccd8ae25d23b7e8903b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7809b6b0ae8fb9c9bd9e177552f6bd"><td class="memItemLeft" align="right" valign="top"><a id="ga3b7809b6b0ae8fb9c9bd9e177552f6bd"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>within</b></td></tr>
<tr class="separator:ga3b7809b6b0ae8fb9c9bd9e177552f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a409f27a28fe5b0e647724ec63b436"><td class="memItemLeft" align="right" valign="top"><a id="ga63a409f27a28fe5b0e647724ec63b436"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>message</b></td></tr>
<tr class="separator:ga63a409f27a28fe5b0e647724ec63b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b4c3aff18e487ff7557ad344464fdd"><td class="memItemLeft" align="right" valign="top"><a id="gae8b4c3aff18e487ff7557ad344464fdd"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>passing</b></td></tr>
<tr class="separator:gae8b4c3aff18e487ff7557ad344464fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12b58463739098bc6e1421ece0a860b"><td class="memItemLeft" align="right" valign="top"><a id="gab12b58463739098bc6e1421ece0a860b"></a>
integer, dimension(e.g. mpi)&#160;</td><td class="memItemRight" valign="bottom"><b>library</b></td></tr>
<tr class="separator:gab12b58463739098bc6e1421ece0a860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292032c1b89d0010530892477f7ed52a"><td class="memItemLeft" align="right" valign="top"><a id="ga292032c1b89d0010530892477f7ed52a"></a>
type(<a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>prev</b> =&gt; null()</td></tr>
<tr class="separator:ga292032c1b89d0010530892477f7ed52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c09669a7dca3c4de6c330d40cc60a3c"><td class="memItemLeft" align="right" valign="top"><a id="ga5c09669a7dca3c4de6c330d40cc60a3c"></a>
type(<a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> =&gt; null()</td></tr>
<tr class="separator:ga5c09669a7dca3c4de6c330d40cc60a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dad5119cfd4906fec0667272be468e"><td class="memItemLeft" align="right" valign="top"><a id="gaa4dad5119cfd4906fec0667272be468e"></a>
type(<a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>head</b> =&gt; null()</td></tr>
<tr class="separator:gaa4dad5119cfd4906fec0667272be468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4751f9b3e421a100bb4dec9007a525"><td class="memItemLeft" align="right" valign="top"><a id="ga2c4751f9b3e421a100bb4dec9007a525"></a>
type(<a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a>), pointer&#160;</td><td class="memItemRight" valign="bottom"><b>tail</b> =&gt; null()</td></tr>
<tr class="separator:ga2c4751f9b3e421a100bb4dec9007a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf940c51e198511031f839dec6e7f1b71"><td class="memItemLeft" align="right" valign="top"><a id="gaf940c51e198511031f839dec6e7f1b71"></a>
integer&#160;</td><td class="memItemRight" valign="bottom"><b>length</b></td></tr>
<tr class="separator:gaf940c51e198511031f839dec6e7f1b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c33cfdab671e1afa5b95acec1d1e5b1"><td class="memItemLeft" align="right" valign="top"><a id="ga8c33cfdab671e1afa5b95acec1d1e5b1"></a>
logical, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_record_timing_data</b> =.TRUE.</td></tr>
<tr class="separator:ga8c33cfdab671e1afa5b95acec1d1e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6624d98bb8dc8289e1a76ee2b0017ec9"><td class="memItemLeft" align="right" valign="top"><a id="ga6624d98bb8dc8289e1a76ee2b0017ec9"></a>
type(<a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a>), target, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_byte</b></td></tr>
<tr class="separator:ga6624d98bb8dc8289e1a76ee2b0017ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90a613436bf4bba787026aeecd058f8d"><td class="memItemLeft" align="right" valign="top"><a id="ga90a613436bf4bba787026aeecd058f8d"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_full_init</b> = -1</td></tr>
<tr class="separator:ga90a613436bf4bba787026aeecd058f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4b4f63882e1ead523312aef7f430c5"><td class="memItemLeft" align="right" valign="top"><a id="gadd4b4f63882e1ead523312aef7f430c5"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_init_true_only</b> = 0</td></tr>
<tr class="separator:gadd4b4f63882e1ead523312aef7f430c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a5e760356d94c51837b8ed3bfbcbef"><td class="memItemLeft" align="right" valign="top"><a id="ga31a5e760356d94c51837b8ed3bfbcbef"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_peset_allocated</b> = 1</td></tr>
<tr class="separator:ga31a5e760356d94c51837b8ed3bfbcbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4fd1673a2cff1568662140d29ed1f3a"><td class="memItemLeft" align="right" valign="top"><a id="gaa4fd1673a2cff1568662140d29ed1f3a"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_clocks_init</b> = 2</td></tr>
<tr class="separator:gaa4fd1673a2cff1568662140d29ed1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0c0ca5f8c2a2769139ad6b2c4ce497"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0c0ca5f8c2a2769139ad6b2c4ce497"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_datatype_list_init</b> = 3</td></tr>
<tr class="separator:ga1d0c0ca5f8c2a2769139ad6b2c4ce497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b17ca8452e65f0a3d31206cf64be3b"><td class="memItemLeft" align="right" valign="top"><a id="gaa1b17ca8452e65f0a3d31206cf64be3b"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_logfile_init</b> = 4</td></tr>
<tr class="separator:gaa1b17ca8452e65f0a3d31206cf64be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42760edcf1874ac719277cb860273eee"><td class="memItemLeft" align="right" valign="top"><a id="ga42760edcf1874ac719277cb860273eee"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_read_namelist</b> = 5</td></tr>
<tr class="separator:ga42760edcf1874ac719277cb860273eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442c5ba6ae0025615fe70694802e2809"><td class="memItemLeft" align="right" valign="top"><a id="ga442c5ba6ae0025615fe70694802e2809"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_etc_unit</b> = 6</td></tr>
<tr class="separator:ga442c5ba6ae0025615fe70694802e2809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fff69706d0583a0d1eb338a59059de"><td class="memItemLeft" align="right" valign="top"><a id="ga44fff69706d0583a0d1eb338a59059de"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>mpp_init_test_requests_allocated</b> = 7</td></tr>
<tr class="separator:ga44fff69706d0583a0d1eb338a59059de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b9d6445f103d775b624ed20446e3e9"><td class="memItemLeft" align="right" valign="top"><a id="gaf0b9d6445f103d775b624ed20446e3e9"></a>
integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><b>input_str_length</b> = 256</td></tr>
<tr class="separator:gaf0b9d6445f103d775b624ed20446e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f26741b5ef128645b1a21cd1c875d25"><td class="memItemLeft" align="right" valign="top"><a id="ga9f26741b5ef128645b1a21cd1c875d25"></a>
character(len=:), dimension(:), allocatable, target, public&#160;</td><td class="memItemRight" valign="bottom"><b>input_nml_file</b></td></tr>
<tr class="separator:ga9f26741b5ef128645b1a21cd1c875d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A set of simple calls to provide a uniform interface to different message-passing libraries. It currently can be implemented either in the SGI/Cray native SHMEM library or in the MPI standard. Other libraries (e.g MPI-2, Co-Array Fortran) can be incorporated as the need arises. </p>
<dl class="section author"><dt>Author</dt><dd>V. Balaji &lt;"V.Balaji@noaa.gov"&gt;</dd></dl>
<p>The data transfer between a processor and its own memory is based on <code>load</code> and <code>store</code> operations upon memory. Shared-memory systems (including distributed shared memory systems) have a single address space and any processor can acquire any data within the memory by <code>load</code> and <code>store</code>. The situation is different for distributed parallel systems. Specialized MPP systems such as the T3E can simulate shared-memory by direct data acquisition from remote memory. But if the parallel code is distributed across a cluster, or across the Net, messages must be sent and received using the protocols for long-distance communication, such as TCP/IP. This requires a `&lsquo;handshaking&rsquo;' between nodes of the distributed system. One can think of the two different methods as involving <code>put</code>s or <code>get</code>s (e.g the SHMEM library), or in the case of negotiated communication (e.g MPI), <code>send</code>s and <code>recv</code>s.</p>
<p>The difference between SHMEM and MPI is that SHMEM uses one-sided communication, which can have very low-latency high-bandwidth implementations on tightly coupled systems. MPI is a standard developed for distributed computing across loosely-coupled systems, and therefore incurs a software penalty for negotiating the communication. It is however an open industry standard whereas SHMEM is a proprietary interface. Besides, the <code>put</code>s or <code>get</code>s on which it is based cannot currently be implemented in a cluster environment (there are recent announcements from Compaq that occasion hope).</p>
<p>The message-passing requirements of climate and weather codes can be reduced to a fairly simple minimal set, which is easily implemented in any message-passing API. <code>mpp_mod</code> provides this API.</p>
<p>Features of <code>mpp_mod</code> include: </p><ol>
<li>
Simple, minimal API, with free access to underlying API for  more complicated stuff.<br  />
 </li>
<li>
Design toward typical use in climate/weather CFD codes.  </li>
<li>
Performance to be not significantly lower than any native API.  </li>
</ol>
<p>This module is used to develop higher-level calls for &lt;LINK
   SRC="mpp_domains.html"&gt;domain decomposition&lt;/LINK&gt; and &lt;LINK
   SRC="mpp_io.html"&gt;parallel I/O&lt;/LINK&gt;. <br  />
 Parallel computing is initially daunting, but it soon becomes second nature, much the way many of us can now write vector code without much effort. The key insight required while reading and writing parallel code is in arriving at a mental grasp of several independent parallel execution streams through the same code (the SPMD model). Each variable you examine may have different values for each stream, the processor ID being an obvious example. Subroutines and function calls are particularly subtle, since it is not always obvious from looking at a call what synchronization between execution streams it implies. An example of erroneous code would be a global barrier call (see &lt;LINK SRC="#mpp_sync"&gt;mpp_sync&lt;/LINK&gt; below) placed within a code block that not all PEs will execute, e.g:</p>
<pre>
   if( pe.EQ.0 )call <a class="el" href="mpp__util__mpi_8inc.html#ad75482ebfad2337cd236ef0998accdc4" title="Synchronize PEs in list.">mpp_sync()</a>
   </pre><p>Here only PE 0 reaches the barrier, where it will wait indefinitely. While this is a particularly egregious example to illustrate the coding flaw, more subtle versions of the same are among the most common errors in parallel code. <br  />
 It is therefore important to be conscious of the context of a subroutine or function call, and the implied synchronization. There are certain calls here (e.g <code>mpp_declare_pelist, mpp_init, mpp_set_stack_size</code>) which must be called by all PEs. There are others which must be called by a subset of PEs (here called a <code>pelist</code>) which must be called by all the PEs in the <code>pelist</code> (e.g <code>mpp_max, mpp_sum, mpp_sync</code>). Still others imply no synchronization at all. I will make every effort to highlight the context of each call in the MPP modules, so that the implicit synchronization is spelt out. <br  />
 For performance it is necessary to keep synchronization as limited as the algorithm being implemented will allow. For instance, a single message between two PEs should only imply synchronization across the PEs in question. A <em>global</em> synchronization (or <em>barrier</em>) is likely to be slow, and is best avoided. But codes first parallelized on a Cray T3E tend to have many global syncs, as very fast barriers were implemented there in hardware. <br  />
 Another reason to use pelists is to run a single program in MPMD mode, where different PE subsets work on different portions of the code. A typical example is to assign an ocean model and atmosphere model to different PE subsets, and couple them concurrently instead of running them serially. The MPP module provides the notion of a <em>current pelist</em>, which is set when a group of PEs branch off into a subset. Subsequent calls that omit the <code>pelist</code> optional argument (seen below in many of the individual calls) assume that the implied synchronization is across the current pelist. The calls <code>mpp_root_pe</code> and <code>mpp_npes</code> also return the values appropriate to the current pelist. The <code>mpp_set_current_pelist</code> call is provided to set the current pelist.  <br  />
</p>
<p>F90 is a strictly-typed language, and the syntax pass of the compiler requires matching of type, kind and rank (TKR). Most calls listed here use a generic type, shown here as <code>MPP_TYPE_</code>. This is resolved in the pre-processor stage to any of a variety of types. In general the MPP operations work on 4-byte and 8-byte variants of <code>integer, real, complex, logical</code> variables, of rank 0 to 5, leading to 48 specific module procedures under the same generic interface. Any of the variables below shown as <code>MPP_TYPE_</code> is treated in this way. </p>


<h3><a id="mpp_error"></a>mpp_error Interface</h3><div class="textblock">Error handler.It is strongly recommended that all error exits pass through <code>mpp_error</code> to assure the program fails cleanly. An individual PE encountering a <code>STOP</code> statement, for instance, can cause the program to hang. The use of the <code>STOP</code> statement is strongly discouraged.Calling mpp_error with no arguments produces an immediate error exit, i.e: </p><pre>
                    call mpp_error
                    call mpp_error()
    </pre><p> are equivalent.The argument order </p><pre>
                    call mpp_error( routine, errormsg, errortype )
    </pre><p> is also provided to support legacy code. In this version of the call, none of the arguments may be omitted.The behaviour of <code>mpp_error</code> for a <code>WARNING</code> can be controlled with an additional call <code>mpp_set_warn_level</code>. </p><pre>
                    call mpp_set_warn_level(ERROR)
    </pre><p> causes <code>mpp_error</code> to treat <code>WARNING</code> exactly like <code>FATAL</code>. </p><pre>
                    call mpp_set_warn_level(WARNING)
    </pre><p> resets to the default behaviour described above.<code>mpp_error</code> also has an internal error state which maintains knowledge of whether a warning has been issued. This can be used at startup in a subroutine that checks if the model has been properly configured. You can generate a series of warnings using <code>mpp_error</code>, and then check at the end if any warnings has been issued using the function <code>mpp_error_state()</code>. If the value of this is <code>WARNING</code>, at least one warning has been issued, and the user can take appropriate action:<pre>
                    if( ... )call mpp_error( WARNING, '...' )
                    if( ... )call mpp_error( WARNING, '...' )
                    if( ... )call mpp_error( WARNING, '...' )
                    ...
                    if( mpp_error_state().EQ.WARNING )call mpp_error( FATAL, '...' )
    </pre><p>  &lt;TEMPLATE&gt; call mpp_error( errortype, routine, errormsg ) &lt;/TEMPLATE&gt; &lt;IN NAME="errortype"&gt; One of <code>NOTE</code>, <code>WARNING</code> or <code>FATAL</code> (these definitions are acquired by use association). <code>NOTE</code> writes <code>errormsg</code> to <code>STDOUT</code>. <code>WARNING</code> writes <code>errormsg</code> to <code>STDERR</code>. <code>FATAL</code> writes <code>errormsg</code> to <code>STDERR</code>, and induces a clean error exit with a call stack traceback. &lt;/IN&gt; </div>

<h3><a id="array_to_char"></a>array_to_char Interface</h3><div class="textblock">Takes a given integer or real array and returns it as a string </div>

<h3><a id="mpp_init"></a>mpp_init Interface</h3><div class="textblock">Initialize <a class="el" href="group__mpp__mod.html">mpp_mod</a>Called to initialize the <code>mpp_mod</code> package. It is recommended that this call be the first executed line in your program. It sets the number of PEs assigned to this run (acquired from the command line, or through the environment variable <code>NPES</code>), and associates an ID number to each PE. These can be accessed by calling <a class="el" href="mpp__util_8inc.html#abf546cd336d5c539e445fb884f98ab6b">mpp_npes</a> and <a class="el" href="mpp__util_8inc.html#acfeba7de56f9dd6000b3fd78f9d56c50">mpp_pe</a>. <br  />
 Example usage: </p><pre class="fragment">       call mpp_init( flags )
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags"</td><td>TYPE="integer"&gt; <code>flags</code> can be set to <code>MPP_VERBOSE</code> to have <code>mpp_mod</code> keep you informed of what it's up to. &lt;/IN&gt; &lt;/SUBROUTINE&gt; </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_exit"></a>mpp_exit Interface</h3><div class="textblock">Exit <code><a class="el" href="group__mpp__mod.html">mpp_mod</a></code>.Called at the end of the run, or to re-initialize <code>mpp_mod</code>, should you require that for some odd reason.This call implies synchronization across all PEs.<br  />
Example usage: </p><pre class="fragment">       call mpp_exit()
</pre> </div>

<h3><a id="mpp_set_stack_size"></a>mpp_set_stack_size Interface</h3><div class="textblock">Allocate module internal workspace.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Integer</td><td>to set stack size to(in words) <code>mpp_mod</code> maintains a private internal array called <code>mpp_stack</code> for private workspace. This call sets the length, in words, of this array.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>mpp_init</code> call sets this workspace length to a default of 32768, and this call may be used if a longer workspace is needed.This call implies synchronization across all PEs.This workspace is symmetrically allocated, as required for efficient communication on SGI and Cray MPP systems. Since symmetric allocation must be performed by <em>all</em> PEs in a job, this call must also be called by all PEs, using the same value of <code>n</code>. Calling <code>mpp_set_stack_size</code> from a subset of PEs, or with unequal argument <code>n</code>, may cause the program to hang.If any MPP call using <code>mpp_stack</code> overflows the declared stack array, the program will abort with a message specifying the stack length that is required. Many users wonder why, if the required stack length can be computed, it cannot also be specified at that point. This cannot be automated because there is no way for the program to know if all PEs are present at that call, and with equal values of <code>n</code>. The program must be rerun by the user with the correct argument to <code>mpp_set_stack_size</code>, called at an appropriate point in the code where all PEs are known to be present. @verbose call mpp_set_stack_size(n) </div>

<h3><a id="mpp_type_create"></a>mpp_type_create Interface</h3><div class="textblock">Create a <a class="el" href="structmpp__mod_1_1mpp__type.html" title="Data types for generalized data transfer (e.g. MPI_Type)">mpp_type</a> variable<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>A field of any numerical or logical type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_of_subsizes</td><td>Integer array of subsizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_of_starts</td><td>Integer array of starts </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dtype_out</td><td>Output variable for created <a class="el" href="structmpp__mod_1_1mpp__type.html">mpp_type</a> </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_max"></a>mpp_max Interface</h3><div class="textblock">Reduction operations. Find the max of scalar a the PEs in pelist result is also automatically broadcast to all PEs &lt;TEMPLATE&gt; call mpp_max( a, pelist ) &lt;/TEMPLATE&gt;<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><code>real</code> or <code>integer</code>, of 4-byte of 8-byte kind. </td></tr>
    <tr><td class="paramname">pelist</td><td>If <code>pelist</code> is omitted, the context is assumed to be the current pelist. This call implies synchronization across the PEs in <code>pelist</code>, or the current pelist if <code>pelist</code> is absent. </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_min"></a>mpp_min Interface</h3><div class="textblock">Get minimum value out of the PEs in pelist Result is also broadcast to all PEs </div>

<h3><a id="mpp_sum"></a>mpp_sum Interface</h3><div class="textblock">Reduction operation.<code>MPP_TYPE_</code> corresponds to any 4-byte and 8-byte variant of <code>integer, real, complex</code> variables, of rank 0 or 1. A contiguous block from a multi-dimensional array may be passed by its starting address and its length, as in <code>f77</code>.Library reduction operators are not required or guaranteed to be bit-reproducible. In any case, changing the processor count changes the data layout, and thus very likely the order of operations. For bit-reproducible sums of distributed arrays, consider using the <code>mpp_global_sum</code> routine provided by the &lt;LINK
 SRC="mpp_domains.html"&gt;<code>mpp_domains</code>&lt;/LINK&gt; module.The <code>bit_reproducible</code> flag provided in earlier versions of this routine has been removed.If <code>pelist</code> is omitted, the context is assumed to be the current pelist. This call implies synchronization across the PEs in <code>pelist</code>, or the current pelist if <code>pelist</code> is absent. Example usage: call mpp_sum( a, length, pelist ) </div>

<h3><a id="mpp_sum_ad"></a>mpp_sum_ad Interface</h3><div class="textblock">Calculates sum of a given numerical array across pe's for adjoint domains </div>

<h3><a id="mpp_gather"></a>mpp_gather Interface</h3><div class="textblock">Gather information onto root pe </div>

<h3><a id="mpp_scatter"></a>mpp_scatter Interface</h3><div class="textblock">Scatter information to the given pelist </div>

<h3><a id="mpp_alltoall"></a>mpp_alltoall Interface</h3><div class="textblock">Scatter a vector across all PEsTranspose the vector and PE index </div>

<h3><a id="mpp_transmit"></a>mpp_transmit Interface</h3><div class="textblock">Basic message-passing call.<code>MPP_TYPE_</code> corresponds to any 4-byte and 8-byte variant of <code>integer, real, complex, logical</code> variables, of rank 0 or 1. A contiguous block from a multi-dimensional array may be passed by its starting address and its length, as in <code>f77</code>.<code>mpp_transmit</code> is currently implemented as asynchronous outward transmission and synchronous inward transmission. This follows the behaviour of <code>shmem_put</code> and <code>shmem_get</code>. In MPI, it is implemented as <code>mpi_isend</code> and <code>mpi_recv</code>. For most applications, transmissions occur in pairs, and are here accomplished in a single call.The special PE designations <code>NULL_PE</code>, <code>ANY_PE</code> and <code>ALL_PES</code> are provided by use association.<code>NULL_PE</code>: is used to disable one of the pair of transmissions.<br  />
 <code>ANY_PE</code>: is used for unspecific remote destination. (Please note that <code>put_pe=ANY_PE</code> has no meaning in the MPI context, though it is available in the SHMEM invocation. If portability is a concern, it is best avoided).<br  />
 <code>ALL_PES</code>: is used for broadcast operations.It is recommended that &lt;LINK
    SRC="#mpp_broadcast"&gt;<code>mpp_broadcast</code>&lt;/LINK&gt; be used for broadcasts.The following example illustrates the use of <code>NULL_PE</code> and <code>ALL_PES</code>:<pre>
    real, dimension(n) :: a
    if( pe.EQ.0 )then
        do p = 1,npes-1
           call mpp_transmit( a, n, p, a, n, NULL_PE )
        end do
    else
        call mpp_transmit( a, n, NULL_PE, a, n, 0 )
    end if</pre><pre>    call mpp_transmit( a, n, ALL_PES, a, n, 0 )
    </pre>The do loop and the broadcast operation above are equivalent.Two overloaded calls <code>mpp_send</code> and <code>mpp_recv</code> have also been provided. <code>mpp_send</code> calls <code>mpp_transmit</code> with <code>get_pe=NULL_PE</code>. <code>mpp_recv</code> calls <code>mpp_transmit</code> with <code>put_pe=NULL_PE</code>. Thus the do loop above could be written more succinctly:<pre>
    if( pe.EQ.0 )then
        do p = 1,npes-1
           call mpp_send( a, n, p )
        end do
    else
        call mpp_recv( a, n, 0 )
    end if
    </pre><p>  &lt;TEMPLATE&gt; call mpp_transmit( put_data, put_len, put_pe, get_data, get_len, get_pe ) &lt;/TEMPLATE&gt; &lt;/INTERFACE&gt; </div>

<h3><a id="mpp_recv"></a>mpp_recv Interface</h3><div class="textblock">Recieve data to another PE<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">get_data</td><td>scalar or array to get written with received data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_len</td><td>size of array to recv from get_data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from_pe</td><td>PE number to receive from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>true for blocking, false for non-blocking. Defaults to true </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tag</td><td>communication tag </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request</td><td>MPI request handle </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_send"></a>mpp_send Interface</h3><div class="textblock">Send data to another PE<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">put_data</td><td>scalar or array to get written with received data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">put_len</td><td>size of array to recv from get_data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to_pe</td><td>PE number to receive from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>true for blocking, false for non-blocking. Defaults to true </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tag</td><td>communication tag </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request</td><td>MPI request handle </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_broadcast"></a>mpp_broadcast Interface</h3><div class="textblock">Perform parallel broadcastsThe <code>mpp_broadcast</code> call has been added because the original syntax (using <code>ALL_PES</code> in <code>mpp_transmit</code>) did not support a broadcast across a pelist.<code>MPP_TYPE_</code> corresponds to any 4-byte and 8-byte variant of <code>integer, real, complex, logical</code> variables, of rank 0 or 1. A contiguous block from a multi-dimensional array may be passed by its starting address and its length, as in <code>f77</code>.Global broadcasts through the <code>ALL_PES</code> argument to &lt;LINK
 SRC="#mpp_transmit"&gt;<code>mpp_transmit</code>&lt;/LINK&gt; are still provided for backward-compatibility.If <code>pelist</code> is omitted, the context is assumed to be the current pelist. <code>from_pe</code> must belong to the current pelist. This call implies synchronization across the PEs in <code>pelist</code>, or the current pelist if <code>pelist</code> is absent.<br  />
Example usage: </p><pre class="fragment">       call mpp_broadcast( data, length, from_pe, pelist )
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to broadcast </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of data to broadcast </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from_pe</td><td>PE to send the data from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pelist</td><td>List of PE's to broadcast across, if not provided uses current list </td></tr>
  </table>
  </dd>
</dl>
</div>

<h3><a id="mpp_chksum"></a>mpp_chksum Interface</h3><div class="textblock">Calculate parallel checksums<em>mpp_chksum</em> is a parallel checksum routine that returns an identical answer for the same array irrespective of how it has been partitioned across processors. \eint_kind is the KIND parameter corresponding to long integers (see discussion on OS-dependent preprocessor directives) defined in the file <a class="el" href="platform_8F90.html" title="File for platform_mod.">platform.F90</a>. \eMPP_TYPE_ corresponds to any 4-byte and 8-byte variant of \einteger, \ereal, \ecomplex, \elogical variables, of rank 0 to 5.Integer checksums on FP data use the F90 <code>TRANSFER()</code> intrinsic.The &lt;LINK SRC="http://www.gfdl.noaa.gov/fms-cgi-bin/cvsweb.cgi/FMS/shared/chksum/chksum.html"&gt;serial checksum module&lt;/LINK&gt; is superseded by this function, and is no longer being actively maintained. This provides identical results on a single-processor job, and to perform serial checksums on a single processor of a parallel job, you only need to use the optional <code>pelist</code> argument. </p><pre>
 use mpp_mod
 integer :: pe, chksum
 real :: a(:)
 pe = <a class="el" href="mpp__util_8inc.html#acfeba7de56f9dd6000b3fd78f9d56c50" title="Returns processor ID. This returns the unique ID associated with a PE. This number runs between 0 and...">mpp_pe()</a>
 chksum = mpp_chksum( a, (/pe/) )
 </pre>The additional functionality of <code>mpp_chksum</code> over serial checksums is to compute the checksum across the PEs in <code>pelist</code>. The answer is guaranteed to be the same for the same distributed array irrespective of how it has been partitioned.If <code>pelist</code> is omitted, the context is assumed to be the current pelist. This call implies synchronization across the PEs in <code>pelist</code>, or the current pelist if <code>pelist</code> is absent. <br  />
 Example usage: </p><pre class="fragment">       mpp_chksum( var, pelist )
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Data to calculate checksum of </td></tr>
    <tr><td class="paramname">pelist</td><td>Optional list of PE's to include in checksum calculation if not using current pelist </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parallel checksum of var across given or implicit pelist </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>

!***********************************************************************
!*                   GNU Lesser General Public License
!*
!* This file is part of the GFDL Flexible Modeling System (FMS).
!*
!* FMS is free software: you can redistribute it and/or modify it under
!* the terms of the GNU Lesser General Public License as published by
!* the Free Software Foundation, either version 3 of the License, or (at
!* your option) any later version.
!*
!* FMS is distributed in the hope that it will be useful, but WITHOUT
!* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
!* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
!* for more details.
!*
!* You should have received a copy of the GNU Lesser General Public
!* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************

!> @defgroup fms_diag_reduction_methods_mod fms_diag_reduction_methods_mod
!> @ingroup diag_manager
!! @brief fms_diag_reduction_methods_mod contains routines that are meant to be used for
!! error checking and setting up to do the reduction methods

!> @file
!> @brief File for @ref fms_diag_reduction_methods_mod

!> @addtogroup fms_diag_reduction_methods_mod
!> @{
module fms_diag_reduction_methods_mod
  use platform_mod, only: r8_kind, r4_kind
  implicit none
  private

  public :: check_indices_order, init_mask, set_weight

  contains

  !> @brief Compares the corresponding bounding indices of the first set with the second set.
  !> @return .TRUE. if any comparison returns true; i.e. the box bounded by the indices of the first set
  !! is out side the box bounded by the indices of the second set.
  LOGICAL FUNCTION compare_two_sets_of_bounds(bounds_a, bounds_b, error_str)
    integer, intent(in) :: bounds_a(:) !< First array with order: (/imin, imax, jmin, jmax, kmin, kmax/)
    integer, intent(in) :: bounds_b(:) !< Second array with the same order as the first
    character(*), intent(out) :: error_str !< Error message to report back

    compare_two_sets_of_bounds = .FALSE.

    if (size(bounds_a) .ne. size(bounds_b)) then
      compare_two_sets_of_bounds = .TRUE.
      error_str = 'fms_diag_reduction_methods_mod::compare_two_sets_of_bounds Error: sizes of sets do not match'
    else
      if ((size(bounds_a) .ne. 6) .and. (size(bounds_b) .ne. 6)) then
        compare_two_sets_of_bounds = .TRUE.
        error_str = 'fms_diag_reduction_methods_mod::compare_two_sets_of_bounds Error: sizes of sets must be 6'
      end if
    end if

    IF (bounds_a(1) .lt. bounds_b(1) .OR. bounds_a(2) .gt. bounds_b(2) .OR. &
      bounds_a(3) .lt. bounds_b(3) .OR. bounds_a(4) .gt. bounds_b(4) .OR. &
      bounds_a(5) .lt. bounds_b(5) .OR. bounds_a(6) .gt. bounds_b(6)) THEN
      compare_two_sets_of_bounds = .TRUE.
      error_str ='First set of bounds=   :   ,   :   ,   :     Second set of bounds=   :   ,   :   ,   :    '
      WRITE(error_str(21:23),'(i3)') bounds_a(1)
      WRITE(error_str(25:27),'(i3)') bounds_a(2)
      WRITE(error_str(29:31),'(i3)') bounds_a(3)
      WRITE(error_str(33:35),'(i3)') bounds_a(4)
      WRITE(error_str(37:39),'(i3)') bounds_a(5)
      WRITE(error_str(41:43),'(i3)') bounds_a(6)
      WRITE(error_str(68:70),'(i3)') bounds_b(1)
      WRITE(error_str(72:74),'(i3)') bounds_b(2)
      WRITE(error_str(76:78),'(i3)') bounds_b(3)
      WRITE(error_str(80:82),'(i3)') bounds_b(4)
      WRITE(error_str(84:86),'(i3)') bounds_b(5)
      WRITE(error_str(88:90),'(i3)') bounds_b(6)
    ELSE
      compare_two_sets_of_bounds = .FALSE.
      error_str = ''
    END IF
  END FUNCTION compare_two_sets_of_bounds

  !> @brief Checks improper combinations of is, ie, js, and je.
  !! @return The error message, empty string if no errors were found
  !> @note accept_data works in either one or another of two modes.
  !! 1. Input field is a window (e.g. FMS physics)
  !! 2. Input field includes halo data
  !! It cannot handle a window of data that has halos.
  !! (A field with no windows or halos can be thought of as a special case of either mode.)
  !! The logic for indexing is quite different for these two modes, but is not clearly separated.
  !! If both the beggining and ending indices are present, then field is assumed to have halos.
  !! If only beggining indices are present, then field is assumed to be a window.
  !> @par
  !! There are a number of ways a user could mess up this logic, depending on the combination
  !! of presence/absence of is,ie,js,je. The checks below should catch improper combinations.
  pure function check_indices_order(is_in, ie_in, js_in, je_in) &
  result(error_msg)
    integer, intent(in), optional :: is_in, ie_in, js_in, je_in !< Indices passed to fms_diag_accept_data()
    character(len=128) :: error_msg !< An error message used only for testing purpose!!!

    error_msg = ""
    IF ( PRESENT(ie_in) ) THEN
      IF ( .NOT.PRESENT(is_in) ) THEN
        error_msg = 'ie_in present without is_in'
        return
      END IF
      IF ( PRESENT(js_in) .AND. .NOT.PRESENT(je_in) ) THEN
        error_msg = 'is_in and ie_in present, but js_in present without je_in'
        return
      END IF
    END IF

    IF ( PRESENT(je_in) ) THEN
      IF ( .NOT.PRESENT(js_in) ) THEN
        error_msg = 'je_in present without js_in'
        return
      END IF
      IF ( PRESENT(is_in) .AND. .NOT.PRESENT(ie_in) ) THEN
        error_msg = 'js_in and je_in present, but is_in present without ie_in'
        return
      END IF
    END IF
  end function check_indices_order

  !> @brief Copies input data to output data with specific type and precision
  !! if the input data is present else sets the output data to a given value val if it is present.
  !! If the value val and the input data are not present, the output data is untouched.
  subroutine real_copy_set(out_data, in_data, val, err_msg)
    real, intent(out) :: out_data !< Proper type copy of in_data
    class(*), intent(in), optional :: in_data !< Data to copy to out_data
    real, intent(in), optional :: val !< Default value to assign to out_data if in_data is absent
    character(len=*), intent(out), optional :: err_msg !< Error message to pass back to caller

    IF ( PRESENT(err_msg) ) err_msg = ''

    IF ( PRESENT(in_data) ) THEN
      SELECT TYPE (in_data)
      TYPE IS (real(kind=r4_kind))
        out_data = in_data
      TYPE IS (real(kind=r8_kind))
        out_data = real(in_data)
      CLASS DEFAULT
        if (fms_error_handler('fms_diag_reduction_methods_mod::real_copy_set',&
          & 'The in_data is not one of the supported types of real(kind=4) or real(kind=8)', err_msg)) THEN
          return
        end if
      END SELECT
    ELSE
      if (present(val)) then
        out_data = val
      else
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::real_copy_set both in_data and val can be absent')
      end if
    END IF
  end subroutine real_copy_set

  !> @brief Allocates `outmask'(second argument) with sizes of the first three dimensions of
  !! the field(first argument).
  !! Initializes the `outmask' depending on presence/absence of `inmask' and `rmask'.
  !! Uses `rmask_threshold' to set the `outmask'.
  subroutine init_mask_3d(field, outmask, rmask_threshold, inmask, rmask, err_msg)
    class(*), intent(in) :: field(:,:,:,:)  !< Dummy variable whose sizes only in the first three
                                            !! dimensions are important
    logical, allocatable, intent(inout) :: outmask(:,:,:) !< Output logical mask
    class(*), intent(in) :: rmask_threshold !< Holds the values 0.5_r4_kind or 0.5_r8_kind, or related threhold values
                                          !! needed to be passed to the math/buffer update functions.
    logical, intent(in), optional :: inmask(:,:,:) !< Input logical mask
    class(*), intent(in), optional :: rmask(:,:,:) !< Floating point input mask value
    character(len=*), intent(out), optional :: err_msg !< Error message to relay back to caller

    character(len=256) :: err_msg_local !< Stores locally generated error message
    integer :: status !< Stores status of memory allocation call

    ! Initialize character strings
    err_msg_local = ''
    if (present(err_msg)) err_msg = ''

    ! Check if outmask is allocated
    if (allocated(outmask)) deallocate(outmask)
    ALLOCATE(outmask(SIZE(field, 1), SIZE(field, 2), SIZE(field, 3)), STAT=status)
    IF ( status .NE. 0 ) THEN
      WRITE (err_msg_local, FMT='("Unable to allocate outmask(",I5,",",I5,",",I5,"). (STAT: ",I5,")")')&
            & SIZE(field, 1), SIZE(field, 2), SIZE(field, 3), status
      if (fms_error_handler('fms_diag_reduction_methods_mod::init_mask_3d', trim(err_msg_local), err_msg)) then
        return
      end if
    END IF

    IF ( PRESENT(inmask) ) THEN
      outmask = inmask
    ELSE
      outmask = .TRUE.
    END IF

    IF ( PRESENT(rmask) ) THEN
      SELECT TYPE (rmask)
        TYPE IS (real(kind=r4_kind))
          select type (rmask_threshold)
          type is (real(kind=r4_kind))
            WHERE (rmask < rmask_threshold) outmask = .FALSE.
          class default
            call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::init_mask_3d'//&
              ' types of rmask and rmask_threshold do not match')
          end select
        TYPE IS (real(kind=r8_kind))
          select type (rmask_threshold)
          type is (real(kind=r8_kind))
            WHERE (rmask < rmask_threshold) outmask = .FALSE.
          class default
            call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::init_mask_3d'//&
              ' types of rmask and rmask_threshold do not match')
          end select
        CLASS DEFAULT
          call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::init_mask_3d'//&
            & ' The rmask is not one of the supported types of real(kind=4) or real(kind=8)')
      END SELECT
    END IF
  end subroutine init_mask_3d

  !> @brief Updates the buffer with the field data based on the value of the flag passed:
  !! time_min for minimum; time_max for maximum.
  subroutine fms_diag_update_extremum(flag, buffer_obj, field_data, recon_bounds, l_start, &
    l_end, is_regional, reduced_k_range, sample, mask, fieldName, hasDiurnalAxis, err_msg)
    integer, intent(in) :: flag !< Flag to indicate what to update: time_min for minimum; time_max for maximum
    class(fmsDiagOutputBuffer_class), intent(inout) :: buffer_obj !< Remapped buffer to update
    class(*), intent(in) :: field_data(:,:,:,:) !< Field data
    type(fmsDiagBoundsHalos_type), intent(inout) :: recon_bounds !< Indices of bounds in the first three dimension
                                                                 !! of the field data
    integer, intent(in) :: l_start(:) !< Local starting indices for the first three dimensions
    integer, intent(in) :: l_end(:)   !< Local ending indices for the first three dimensions
    logical, intent(in) :: is_regional !< Flag indicating if the current PE takes part in send_data
    logical, intent(in) :: reduced_k_range !< Flag indicating if the field has zbounds
    integer, intent(in) :: sample !< Index along the diurnal time axis
    logical, intent(in) :: mask(:,:,:,:) !< Must be out of range mask
    character(len=*), intent(in) :: fieldName !< Field name for error reporting
    logical, intent(in) :: hasDiurnalAxis !< Flag to indicate if the buffer has a diurnal axis
    character(len=*), intent(inout), optional :: err_msg !< Error mesage to report back

    integer :: is, js, ks !< Starting indices in the I, J, and K dimensions
    integer :: ie, je, ke !< Ending indices in the I, J, and K dimensions
    integer :: hi, hj !< Halo sizes in the I, and J dimensions
    integer :: f1, f2 !< Updated starting and ending indices in the I dimension
    integer :: f3, f4 !< Updated starting and ending indices in the J dimension
    integer :: ksr, ker !< Reduced indices in the K dimension
    integer :: i, j, k !< For loops
    integer :: i1, j1, k1 !< Intermediate computed indices
    character(len=128) :: err_msg_local !< Stores local error message
    class(*), pointer :: ptr_buffer(:,:,:,:,:) !< Pointer to 5D buffer for remapping
    type(fmsDiagIbounds_type) :: IJKBounds !< Bounding object for the I, J, and K indices

    !> Get the `bounds3D` member of the `recon_bounds`
    IJKBounds = recon_bounds%get_bounds3D() !< Assignment of data structure with intrinsic type members may work!!!

    !> Unpack recon_bounds
    is = IJKBounds%get_imin()
    js = IJKBounds%get_jmin()
    ks = IJKBounds%get_kmin()
    ie = IJKBounds%get_imax()
    je = IJKBounds%get_jmax()
    ke = IJKBounds%get_kmax()
    hi = recon_bounds%get_hi()
    f1 = recon_bounds%get_fis()
    f2 = recon_bounds%get_fie()
    hj = recon_bounds%get_hj()
    f3 = recon_bounds%get_fjs()
    f4 = recon_bounds%get_fje()

    if (flag .ne. 3 .and. flag .ne. 4) then
      call mpp_error( FATAL, "fms_diag_reduction_methods_mod::fms_diag_update_extremum: flag must be either 3 or 4.")
    end if

    !! TODO: remap buffer before passing to subroutines update_scalar_extremum and update_array_extremum
    ptr_buffer => buffer_obj%remap_buffer(fieldName, hasDiurnalAxis)

    ! Update buffer
    regional_if: IF (is_regional) THEN
      DO k = l_start(3), l_end(3)
        k1 = k - l_start(3) + 1
        DO j = js, je
          DO i = is, ie
            IF ( l_start(1)+hi <= i .AND. i <= l_end(1)+hi .AND. l_start(2)+hj <= j .AND. &
              & j <= l_end(2)+hj ) THEN
              i1 = i-l_start(1)-hi+1
              j1=  j-l_start(2)-hj+1
              select type (buffer_obj)
              type is (outputBuffer0d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              type is (outputBuffer1d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              type is (outputBuffer2d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              type is (outputBuffer3d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              type is (outputBuffer4d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              type is (outputBuffer5d_type)
                call update_scalar_extremum(flag, field_data, ptr_buffer, mask, sample, &
                  recon_bounds, (/i,j,k/), (/i1,j1,k1/))
              class default
                call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
                  ' regional buffer_obj is not one of the support buffer types: outputBuffer0d_type'//&
                  ' outputBuffer1d_type outputBuffer2d_type outputBuffer3d_type'//&
                  ' outputBuffer4d_type outputBuffer5d_type')
              end select
            end if
          END DO
        END DO
      END DO
    ELSE !< if not regional
      reduced_k_range_if: IF (reduced_k_range) THEN
        call IJKBounds%set_kbounds(l_start(3), l_end(3))
        select type (buffer_obj)
        type is (outputBuffer0d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer1d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer2d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer3d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer4d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer5d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        class default
          call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum in reduced_k_range_if'//&
            ' regional buffer_obj is not one of the support buffer types: outputBuffer0d_type'//&
            ' outputBuffer1d_type outputBuffer2d_type outputBuffer3d_type'//&
            ' outputBuffer4d_type outputBuffer5d_type')
        end select
      ELSE !< does not have reduced_k_range
        debug_diag_if: IF ( debug_diag_manager ) THEN
          ! Compare bounds {is-hi, ie-hi, js-hj, je-hj, ks, ke} with the bounds of first three dimensions of the buffer
          if (compare_two_sets_of_bounds((/is-hi, ie-hi, js-hj, je-hj, ks, ke/), &
            (/LBOUND(ptr_buffer,1), UBOUND(ptr_buffer,1), LBOUND(ptr_buffer,2), UBOUND(ptr_buffer,2), &
            LBOUND(ptr_buffer,3), UBOUND(ptr_buffer,3)/), err_msg_local)) THEN
            IF ( fms_error_handler('fms_diag_object_mod::fms_diag_update_extremum', err_msg_local, err_msg) ) THEN
              RETURN
            END IF
          END IF
        END IF debug_diag_if

        !> If no error above, do update the buffer
        select type (buffer_obj)
        type is (outputBuffer0d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer1d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer2d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer3d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer4d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        type is (outputBuffer5d_type)
          call update_array_extremum(flag, field_data, ptr_buffer, mask, sample, recon_bounds, reduced_k_range)
        class default
          call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
            ' regional buffer_obj is not one of the support buffer types: outputBuffer0d_type'//&
            ' outputBuffer1d_type outputBuffer2d_type outputBuffer3d_type'//&
            ' outputBuffer4d_type outputBuffer5d_type')
        end select
      END IF reduced_k_range_if
    end if regional_if

    ! Reset counter count_0d of the buffer object
    select type (buffer_obj)
    type is (outputBuffer0d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    type is (outputBuffer1d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    type is (outputBuffer2d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    type is (outputBuffer3d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    type is (outputBuffer4d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    type is (outputBuffer5d_type)
      select type (real_counter => buffer_obj%count_0d)
      type is (real(kind=r4_kind))
        real_counter(sample) = 1.0_r4_kind
      type is (real(kind=r8_kind))
        real_counter(sample) = 1.0_r8_kind
      class default
        call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum'//&
          ' Unsupported type of buffer_obj%count_0d')
      end select
    class default
      call mpp_error(FATAL, 'fms_diag_reduction_methods_mod::fms_diag_update_extremum unsupported buffer type')
    end select
  end subroutine fms_diag_update_extremum

  !> @brief Updates individual element of the buffer associated with indices in running_indx1 and running_indx2
  subroutine update_scalar_extremum(flag, field_data, buffer, mask, sample, recon_bounds, &
    running_indx1, running_indx2)
    integer, intent(in) :: flag !< Flag indicating maximum(time_max) or minimum(time_min)
    class(*), intent(in) :: field_data(:,:,:,:) !< Field data
    class(*), intent(inout) :: buffer(:,:,:,:,:) !< Remapped output buffer
    logical, intent(in) :: mask(:,:,:,:) !< Update mask
    integer, intent(in) :: sample !< diurnal sample index
    type(fmsDiagBoundsHalos_type), intent(in) :: recon_bounds !< Holds starting and ending indices in the
                                                              !! I, J, and K dimensions and
                                                              !! halo sizes in the I, and J dimensions
    integer, intent(in) :: running_indx1(3) !< Holds indices i, j, and k
    integer, intent(in) :: running_indx2(3) !< Holds indices i1, j1, and k1

    type(fmsDiagIbounds_type) :: IJKBounds !< Bounding object for the I, J, and K indices
    integer :: i, j, k !< Unpack running_indx1 to
    integer :: i1, j1, k1 !< Unpack running_indx2 to
    integer :: is, js, ks !< Starting indices in the I, J, and K dimensions
    integer :: ie, je, ke !< Ending indices in the I, J, and K dimensiions
    integer :: hi, hj !< Halo sizes in the I, and J dimensions

    !> Check flag for unsupported operation
    if (flag .ne. time_max .and. flag .ne. time_min) then
      call mpp_error(FATAL, "fms_diag_reduction_methods_mod::fms_diag_scalar_extremum &
        unsupported reduction method")
    endif

    ! Initialize i, j, and k
    i = running_indx1(1)
    j = running_indx1(2)
    k = running_indx1(3)

    ! Initialize i1, j1, and k1
    i1 = running_indx2(1)
    j1 = running_indx2(2)
    k1 = running_indx2(3)

    !> Get the `bounds3D` member of the `recon_bounds`
    IJKBounds = recon_bounds%get_bounds3D() !< Assignment of data structure with intrinsic type members may work!!!

    !> Unpack index bounds
      is = IJKBounds%get_imin()
      js = IJKBounds%get_jmin()
      ks = IJKBounds%get_kmin()
      ie = IJKBounds%get_imax()
      je = IJKBounds%get_jmax()
      ke = IJKBounds%get_kmax()
      hi = recon_bounds%get_hi()
      hj = recon_bounds%get_hj()

    ! Select proper type and update the buffer
    select type (field_data)
    type is (real(kind=r4_kind))
      select type (buffer)
      type is (real(kind=r4_kind))
        minimum_if: if (flag .eq. time_min) then
        !> Update the buffer with the current minimum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) <&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        else !< if not minimum, check for maximum
        !> Update the buffer with the current maximum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) >&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_scalar_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (real(kind=r8_kind))
      select type (buffer)
      type is (real(kind=r8_kind))
        minimum_if: if (flag .eq. time_min) then
        ! Update the buffer with the current minimum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) <&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        else
        ! Update the buffer with the current maximum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) >&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        endif minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_scalar_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (integer(kind=i4_kind))
      select type (buffer)
      type is (integer(kind=i4_kind))
        minimum_if: if (flag .eq. time_min) then
        ! Update the buffer with the current minimum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) <&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        else
        ! Update the buffer with the current maximum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) >&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        endif minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_scalar_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (integer(kind=i8_kind))
      select type (buffer)
      type is (integer(kind=i8_kind))
        minimum_if: if (flag .eq. time_min) then
        ! Update the buffer with the current minimum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) <&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        else
        ! Update the buffer with the current maximum
          where (mask(i-is+1+hi,j-js+1+hj,k,:) .AND. field_data(i-is+1+hi,j-js+1+hj,k,:) >&
            buffer(i1,j1,k1,:,sample))
            buffer(i1,j1,k1,:,sample) = field_data(i-is+1+hi,j-js+1+hj,k,:)
          end where
        end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_scalar_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    class default
      call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_scalar_extremum unsupported field data type")
    end select
  end subroutine update_scalar_extremum

  !> @brief Updates a chunk of the buffer defined by the bounds in recon_bounds
  subroutine update_array_extremum(flag, field_data, buffer, mask, sample, recon_bounds, reduced_k_range)
    integer :: flag !< Flag indicating maximum(time_max) or minimum(time_min)
    class(*), intent(in) :: field_data(:,:,:,:) !< Field data
    class(*), intent(inout) :: buffer(:,:,:,:,:) !< Remapped output buffer
    logical, intent(in) :: mask(:,:,:,:) !< Updated mask
    integer, intent(in) :: sample !< diurnal sample index
    type(fmsDiagBoundsHalos_type), intent(in) :: recon_bounds !< Object to hold starting and ending indices
                                                              !! in the I, J, and K dimensions; also holds
                                                              !! halo sizes in the I, and J dimensions
    logical, intent(in) :: reduced_k_range !< Flag indicating if the range in the K dimension is present

    integer :: is, js, ks !< Starting indices in the I, J, and K dimensions
    integer :: ie, je, ke !< Ending indices in the I, J, and K dimensions
    integer :: hi, hj !< Halo sizes in the I, and J dimensions
    integer :: f1, f2 !< Updated starting and ending indices in the I dimension
    integer :: f3, f4 !< Updated starting and ending indices in the J dimension
    type(fmsDiagIbounds_type) :: IJKBounds !< Bounding object for the I, J, and K indices

    !> Check flag for unsupported operation
    if (flag .ne. time_max .and. flag .ne. time_min) then
      call mpp_error(FATAL, "fms_diag_reduction_methods_mod::fms_diag_scalar_extremum &
        unsupported reduction method")
    endif

    !> Get the `bounds3D` member of the `recon_bounds`
    IJKBounds = recon_bounds%get_bounds3D() !< Assignment of data structure with intrinsic type members may work!!!

    !> Unpack bounds (/is, js, ks, ie, je, ke, hi, f1, f2, hj, f3, f4/)
    is = IJKBounds%get_imin()
    js = IJKBounds%get_jmin()
    ks = IJKBounds%get_kmin()
    ie = IJKBounds%get_imax()
    je = IJKBounds%get_jmax()
    ke = IJKBounds%get_kmax()
    hi = recon_bounds%get_hi()
    f1 = recon_bounds%get_fis()
    f2 = recon_bounds%get_fie()
    hj = recon_bounds%get_hj()
    f3 = recon_bounds%get_fjs()
    f4 = recon_bounds%get_fje()

    ! Select proper type and update the buffer
    select type (field_data)
    type is (real(kind=r4_kind))
      select type (buffer)
      type is (real(kind=r4_kind))
        minimum_if: if (flag .eq. time_min) then
        !> Update the buffer with the current minimum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        else
        !> Update the buffer with the current maximum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:)>&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_array_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (real(kind=r8_kind))
      select type (buffer)
      type is (real(kind=r8_kind))
          minimum_if: if (flag .eq. time_min) then
          !> Update the buffer with the current minimum
            if (reduced_k_range) then
              ! recon_bounds must have ks = ksr and ke = ker
              WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
                buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
                buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
            else
              WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
                buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
                buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
            end if
          else
          !> Update the buffer with the current maximum
            if (reduced_k_range) then
              ! recon_bounds must have ks = ksr and ke = ker
              WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
                buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
                buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
            else
              WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:)>&
                buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
                buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
            end if
          end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_array_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (integer(kind=i4_kind))
      select type (buffer)
      type is (integer(kind=i4_kind))
        minimum_if: if (flag .eq. time_min) then
        !> Update the buffer with the current minimum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        else
        !> Update the buffer with the current maximum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:)>&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_array_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    type is (integer(kind=i8_kind))
      select type (buffer)
      type is (integer(kind=i8_kind))
        minimum_if: if (flag .eq. time_min) then
        !> Update the buffer with the current minimum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        else
        !> Update the buffer with the current maximum
          if (reduced_k_range) then
            ! recon_bounds must have ks = ksr and ke = ker
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:) <&
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,:,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          else
            WHERE (mask(f1:f2,f3:f4,ks:ke,:) .AND. field_data(f1:f2,f3:f4,ks:ke,:)>&
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample)) &
              buffer(is-hi:ie-hi,js-hj:je-hj,ks:ke,:,sample) = field_data(f1:f2,f3:f4,ks:ke,:)
          end if
        end if minimum_if
      class default
        call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_array_extremum"//&
          " buffer type does not match with field_data type.")
      end select
    class default
      call mpp_error( FATAL, "fms_diag_reduction_methods_mod::update_array_extremum unsupported field data type")
    end select
  end subroutine update_array_extremum
#endif
end module fms_diag_reduction_methods_mod
  !> @brief Sets the logical mask based on mask or rmask
  !> @return logical mask
  function init_mask(rmask, mask, field) &
  result(oor_mask)
    LOGICAL,  DIMENSION(:,:,:,:), pointer, INTENT(in) :: mask  !< The location of the mask
    CLASS(*), DIMENSION(:,:,:,:), pointer, INTENT(in) :: rmask !< The masking values
    CLASS(*), DIMENSION(:,:,:,:),          intent(in) :: field !< Field_data

    logical, allocatable, dimension(:,:,:,:) :: oor_mask !< mask

    ALLOCATE(oor_mask(SIZE(field, 1), SIZE(field, 2), SIZE(field, 3), SIZE(field, 4)))
    oor_mask = .true.

    if (associated(mask)) then
      oor_mask = mask
    elseif (associated(rmask)) then
      select type (rmask)
      type is (real(kind=r8_kind))
        WHERE (rmask < 0.5_r8_kind) oor_mask = .FALSE.
      type is (real(kind=r4_kind))
        WHERE (rmask < 0.5_r4_kind) oor_mask = .FALSE.
      end select
    endif

  end function init_mask

  !> @brief Sets the weight based on the weight passed into send_data (1.0_r8_kind if the weight is not passed in)
  !! The weight will be saved as an r8 and converted to r4 as needed
  !! @return weight to use when averaging
  pure function set_weight(weight) &
  result(out_weight)
    CLASS(*), INTENT(in), OPTIONAL :: weight !< The weight use when averaging

    real(kind=r8_kind) :: out_weight

    out_weight = 1.0_r8_kind
    if (present(weight)) then
      select type(weight)
      type is (real(kind=r8_kind))
        out_weight = real(weight, kind = r8_kind)
      type is (real(kind=r4_kind))
        out_Weight = real(weight, kind = r8_kind)
      end select
    endif
  end function set_weight

end module fms_diag_reduction_methods_mod
!> @}
! close documentation grouping
